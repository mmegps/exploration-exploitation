import numpy as np

# Utility functions
def updateIndividual (I, O, M, prob):
    for dim in range(0, M):
        if O[dim] != 0:
            if (np.random.choice(2, p = [prob, 1-prob]) == 0):
                I[dim] = O[dim]

def VecSimm(Vec1, Vec2):
    return len(list(x for x,y in zip(Vec1, Vec2) if x == y))

def VecDiff(Vec1, Vec2):
    return len(list(x for x,y in zip(Vec1, Vec2) if x != y))

def findDominantBelief (I, S, i):
    lenS =len(S)
    count_1 = count_0 = count_M1 = 0

    # Possible beliefs: 1, 0, -1
    for j in range(0, lenS):
        if I[j][i] == 1:
            count_1 += 1
        elif I[j][i] == 0:
            count_0 += 1
        else:
            count_M1 += 1

    maxCount = max(count_1, count_0, count_M1)
    #print "count 1/0/-1 ", count_1, count_0, count_M1

    if maxCount == count_1:
        return 1
    elif maxCount == count_0:
        return 0
    else:
        return -1

# Setup the Simualtion
# Socialzation Rate
p1 = 0.1
# Organization Learning Rate
p2 = 0.9

# Reality, M-tuple [1, -1]
# Organisation Code, M-tuple [1, 0, -1] - Initially 0s
# Individuals, count N - [-1, 0, 1]

# Dimension, for O, I and R, original experiment 30
M = 12
# Number of Individuals, original experiment 50
N = 16
# iterations, original experiment 80
iterCount = 10

# Model Reality, R
# X = np.random.randint(0, 2, size=M)
R = 2*np.random.randint(0, 2, size=M) - 1

# Model Organization Code, initially 0's

O = np.zeros(M, dtype=np.int)

# Model Individuals
I = np.random.randint(-1, 2, size=(N, M))
print
print "Reality"
print R
print "Org Code"
print O
print "Individuals"
AvgIndSimmIndexStart = 0
for i in range(0, N):
    avgSimm = VecSimm(I[i], O)
    print I[i], "Similarity with Org Code:", avgSimm
    AvgIndSimmIndexStart += avgSimm
print "Proportion of Reality represented by the Individuals (on average):", round(float(AvgIndSimmIndexStart) / N, 1)
print
print "Socialzation Rate:", p1
print "Organization Learning Rate:", p2
print
print "*** Simualtion Begin ***"

# Total iterations in the simulation
for loop in range(0, iterCount):
    print "*** Iteration: ", loop, "***"

    # Adjust for Socialzation Rate (Individual learning)
    for i in range(0, N):
        # Update Individual i with probability p1 with Org Code, O
        # and I/O dimensions as M
        updateIndividual(I[i], O, M, p1)

    # Adjust for Organisational learning
    # Step 1: Make a set of Individuals who agree more with the Reality, than
    # the Organisation. Call this group "Superior Group".
    S = []
    SimmOR = VecSimm(O, R)
    print "Similarity between Org Code and Reality:", SimmOR

    for i in range(0, N):
        if (VecSimm(I[i], R) > SimmOR):
            S.append(i)
    print "Superior Group: ", S
    print "Superior Group Size: ", len(S)

    # Step 2: For every vector dimension, Find dominant belief ammong
    # Superior Group and uptate O.
    print "Org Code before iteration:"
    print O

    if len(S) > 0:
        for i in range(0, M):
            if (np.random.choice(2, p = [p2, 1-p2]) == 0):
                dBelief = findDominantBelief (I, S, i)
                print "Component:", i, ",Dominant Belief:", dBelief
                O[i] = dBelief

    print "Org Code after iteration:"
    print O
    print

print "*** Simualtion End ***"
print
print "*** Observations ***"
print "[1] Individuals"
print
AvgIndSimmIndexEnd = 0
for i in range(0, N):
    avgSimm = VecSimm(I[i], O)
    print I[i], "Similarity with Org Code:", avgSimm
    AvgIndSimmIndexEnd += avgSimm
print "Proportion of Reality represented by the Individuals (on average):", round(float(AvgIndSimmIndexEnd) / N, 1)
print
print "New Organisation Code "
print O

print "Reality"
print R

print "Final Similarity between Org Code and Reality ", VecSimm(R, O)
print "Proportion of Reality correctly represented in Org Code:", round(100.0 * VecSimm(R, O) / M, 1), "%"
